package assemblers

import (
	"context"
	"fmt"
	"slices"

	"github.com/ThreeDotsLabs/watermill/message"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/sqs"
	"github.com/cloudevents/sdk-go/v2/event"
	"github.com/lamassuiot/lamassuiot/v2/pkg/config"
	"github.com/lamassuiot/lamassuiot/v2/pkg/eventbus"
	"github.com/lamassuiot/lamassuiot/v2/pkg/helpers"
	lms_slices "github.com/lamassuiot/lamassuiot/v2/pkg/helpers/slices"
	"github.com/lamassuiot/lamassuiot/v2/pkg/models"
	"github.com/lamassuiot/lamassuiot/v2/pkg/resources"
	"github.com/lamassuiot/lamassuiot/v2/pkg/services"
	"github.com/lamassuiot/lamassuiot/v2/pkg/services/iot"
	"github.com/sirupsen/logrus"
)

func AssembleAWSIoTManagerService(conf config.IotAWS, caService services.CAService, dmsService services.DMSManagerService, deviceService services.DeviceManagerService) (*iot.AWSCloudConnectorService, error) {
	lSvc := helpers.ConfigureLogger(conf.Logs.Level, "AWS IoT Connector", "Service")
	lMessaging := helpers.ConfigureLogger(conf.SubscriberEventBus.LogLevel, "AWS IoT Connector", "Event Bus")

	awsCfg, err := config.GetAwsSdkConfig(conf.AWSSDKConfig)
	if err != nil {
		return nil, fmt.Errorf("could not get aws config: %s", err)
	}

	awsConnectorSvc, err := iot.NewAWSCloudConnectorServiceService(iot.AWSCloudConnectorBuilder{
		Conf:        *awsCfg,
		Logger:      lSvc,
		ConnectorID: conf.ConnectorID,
		CaSDK:       caService,
		DmsSDK:      dmsService,
		DeviceSDK:   deviceService,
	})
	if err != nil {
		logrus.Fatal(err)
	}

	eventBusRouter, err := eventbus.NewEventBusRouter(conf.SubscriberEventBus, "aws-connector", lMessaging)
	if err != nil {
		return nil, fmt.Errorf("could not setup event bus: %s", err)
	}

	sub, err := eventbus.NewEventBusSubscriber(conf.SubscriberEventBus, "aws-connector", lMessaging)
	if err != nil {
		lMessaging.Errorf("could not generate Event Bus Subscriber: %s", err)
		return nil, err
	}

	eventBusRouter.AddNoPublisherHandler("#-aws-connector", "#", sub, GetAWSIoTConnectorEventHandler(lMessaging, awsConnectorSvc))
	go eventBusRouter.Run(context.Background())

	go func() {
		lSvc.Infof("starting SQS thread")
		sqsQueueName := fmt.Sprintf("https://sqs.%s.amazonaws.com/%s/%s", awsConnectorSvc.Region, awsConnectorSvc.AccountID, "Lamassu-IoT-SYNC-EventBridgeOutput6A8BBEEC-LaYbNuW753SC")

		for {
			lSvc.Debugf("reading from queue %s", sqsQueueName)
			sqsOutput, err := awsConnectorSvc.SqsSDK.ReceiveMessage(context.Background(), &sqs.ReceiveMessageInput{
				QueueUrl:            aws.String(sqsQueueName),
				MaxNumberOfMessages: int32(10),
				WaitTimeSeconds:     int32(20),
			})

			if err != nil {
				lSvc.Errorf("could not receive SQS messages: %s", err)
				return
			}

			totalInBatch := len(sqsOutput.Messages)
			lSvc.Tracef("received sqs batch messages of size %d ", totalInBatch)
			for idx, sqsMessage := range sqsOutput.Messages {
				lSvc.Tracef("message [%d/%d]: %s", idx+1, totalInBatch, *sqsMessage.Body)
			}
		}
	}()

	return awsConnectorSvc, nil
}

func GetAWSIoTConnectorEventHandler(lMessaging *logrus.Entry, svc *iot.AWSCloudConnectorService) func(*message.Message) error {
	return func(m *message.Message) error {
		event, err := eventbus.ParseCloudEvent(m.Payload)
		if err != nil {
			lMessaging.Errorf("Something went wrong while processing cloud event: %s", err)
		}

		err = mainAwsConnectorEventHandler(event, *svc, lMessaging)
		if err != nil {
			return err
		}

		return nil
	}
}

func mainAwsConnectorEventHandler(event *event.Event, svc iot.AWSCloudConnectorService, logger *logrus.Entry) error {
	logDecodeError := func(eventID string, eventType string, modelObject string, err error) {
		logger.Errorf("could not decode event '%s' into model '%s' object. Skipping event with ID %s: %s", eventType, modelObject, eventID, err)
	}

	logger.Tracef("incoming cloud event: type=%s source=%s id=%s", event.Type(), event.Source(), event.ID())
	if event.Source() == models.AWSIoTSource(svc.ConnectorID) {
		//this prevents processing events generated by this service, and as a consequence of Updating/Creating/Deleting on other Lamassu services,
		//otherwise, the would be a possible infinite loop
		logger.Tracef("dropping cloud event. event source indicates that was originated by this container/service: type=%s source=%s id=%s", event.Type(), event.Source(), event.ID())
		return nil
	}

	switch event.Type() {
	case string(models.EventBindDeviceIdentityKey):
		bindEvent, err := eventbus.GetEventBody[models.BindIdentityToDeviceOutput](event)
		if err != nil {
			logDecodeError(event.ID(), event.Type(), "Certificate", err)
			return nil
		}

		dms := bindEvent.DMS

		var dmsAwsAutomationConfig models.IotAWSDMSMetadata
		hasKey, err := helpers.GetMetadataToStruct(dms.Metadata, models.AWSIoTMetadataKey(svc.ConnectorID), &dmsAwsAutomationConfig)
		if err != nil {
			err = fmt.Errorf("could not decode metadata with key %s: %s", models.CAMetadataMonitoringExpirationDeltasKey, err)
			logger.Error(err)
			return err
		}

		if !hasKey {
			logrus.Warnf("skipping event %s, DMS doesn't have %s key", event.Type(), models.AWSIoTMetadataKey(svc.ConnectorID))
			return nil
		}

		if dmsAwsAutomationConfig.RegistrationMode == models.AutomaticAWSIoTRegistrationMode {
			thingID := bindEvent.Certificate.Subject.CommonName
			logrus.Infof("registering %s device", thingID)
			err = svc.RegisterAndAttachThing(iot.RegisterAndAttachThingInput{
				DeviceID:               thingID,
				DMSIoTAutomationConfig: dmsAwsAutomationConfig,
				BindedIdentity:         *bindEvent,
			})
			if err != nil {
				err = fmt.Errorf("something went wrong while registering device %s: %s", thingID, err)
				logger.Error(err)
				return err
			}
		}

		return nil

	case string(models.EventUpdateDeviceMetadataKey):
		deviceUpdate, err := eventbus.GetEventBody[models.UpdateModel[models.Device]](event)
		if err != nil {
			logDecodeError(event.ID(), event.Type(), "Device", err)
			return nil
		}

		device := deviceUpdate.Updated
		var deviceMetaAWS models.DeviceAWSMetadata
		hasKey, err := helpers.GetMetadataToStruct(device.Metadata, models.AWSIoTMetadataKey(svc.ConnectorID), &deviceMetaAWS)
		if err != nil {
			err = fmt.Errorf("could not decode metadata with key %s: %s", models.AWSIoTMetadataKey(svc.ConnectorID), err)
			logger.Error(err)
			return err
		}

		if !hasKey {
			logrus.Warnf("skipping event %s, Device doesn't have %s key", event.Type(), models.AWSIoTMetadataKey(svc.ConnectorID))
			return nil
		}

		dms, err := svc.DmsSDK.GetDMSByID(context.Background(), services.GetDMSByIDInput{
			ID: device.DMSOwner,
		})
		if err != nil {
			err = fmt.Errorf("could not get DMS %s: %s", device.DMSOwner, err)
			logger.Error(err)
			return err
		}

		var dmsAWSConf models.IotAWSDMSMetadata
		hasKey, err = helpers.GetMetadataToStruct(dms.Metadata, models.AWSIoTMetadataKey(svc.ConnectorID), &dmsAWSConf)
		if err != nil {
			err = fmt.Errorf("could not decode metadata with key %s: %s", models.AWSIoTMetadataKey(svc.ConnectorID), err)
			logger.Error(err)
			return err
		}

		if !hasKey {
			logrus.Warnf("skipping event %s, DMS doesn't have %s key", event.Type(), models.AWSIoTMetadataKey(svc.ConnectorID))
			return nil
		}

		if len(deviceMetaAWS.Actions) > 0 {
			err = svc.UpdateDeviceShadow(iot.UpdateDeviceShadowInput{
				DeviceID:               device.ID,
				RemediationActionsType: deviceMetaAWS.Actions,
				DMSIoTAutomationConfig: dmsAWSConf,
			})
			if err != nil {
				err = fmt.Errorf("something went wrong while updating %s Thing Shadow: %s", device.ID, err)
				logger.Error(err)
				return err
			}
		}

		return nil

	case string(models.EventUpdateCertificateMetadataKey):
		certUpdate, err := eventbus.GetEventBody[models.UpdateModel[models.Certificate]](event)
		if err != nil {
			logDecodeError(event.ID(), event.Type(), "Certificate", err)
			return nil
		}

		cert := certUpdate.Updated

		var certExpirationDeltas models.CAMetadataMonitoringExpirationDeltas
		hasKey, err := helpers.GetMetadataToStruct(cert.Metadata, models.CAMetadataMonitoringExpirationDeltasKey, &certExpirationDeltas)
		if err != nil {
			err = fmt.Errorf("could not decode metadata with key %s: %s", models.CAMetadataMonitoringExpirationDeltasKey, err)
			logger.Error(err)
			return err
		}

		if !hasKey {
			logrus.Warnf("skipping event %s, Certificate doesn't have %s key", event.Type(), models.CAMetadataMonitoringExpirationDeltasKey)
			return nil
		}

		preventiveIdx := slices.IndexFunc(certExpirationDeltas, func(med models.MonitoringExpirationDelta) bool {
			return med.Name == "Preventive"
		})

		var attachedBy models.CAAttachedToDevice
		hasKey, err = helpers.GetMetadataToStruct(cert.Metadata, models.CAAttachedToDeviceKey, &attachedBy)
		if err != nil {
			err = fmt.Errorf("could not decode metadata with key %s: %s", models.CAAttachedToDeviceKey, err)
			logger.Error(err)
			return err
		}

		if !hasKey {
			logrus.Warnf("skipping event %s, Certificate doesn't have %s key", event.Type(), models.CAAttachedToDeviceKey)
			return nil
		}

		dms, err := svc.DmsSDK.GetDMSByID(context.Background(), services.GetDMSByIDInput{
			ID: attachedBy.AuthorizedBy.RAID,
		})
		if err != nil {
			err = fmt.Errorf("could not get DMS %s: %s", attachedBy.AuthorizedBy.RAID, err)
			logger.Error(err)
			return err
		}

		var dmsAWSConf models.IotAWSDMSMetadata
		hasKey, err = helpers.GetMetadataToStruct(dms.Metadata, models.AWSIoTMetadataKey(svc.ConnectorID), &dmsAWSConf)
		if err != nil {
			err = fmt.Errorf("could not decode metadata with key %s: %s", models.AWSIoTMetadataKey(svc.ConnectorID), err)
			logger.Error(err)
			return err
		}

		if !hasKey {
			logrus.Warnf("skipping event %s, DMS doesn't have %s key", event.Type(), models.AWSIoTMetadataKey(svc.ConnectorID))
			return nil
		}

		if preventiveIdx >= 0 && certExpirationDeltas[preventiveIdx].Triggered {
			err = svc.UpdateDeviceShadow(iot.UpdateDeviceShadowInput{
				DeviceID:               cert.Subject.CommonName,
				RemediationActionsType: []models.RemediationActionType{models.RemediationActionUpdateCertificate},
				DMSIoTAutomationConfig: dmsAWSConf,
			})
			if err != nil {
				err = fmt.Errorf("something went wrong while updating %s Thing Shadow: %s", attachedBy.DeviceID, err)
				logger.Error(err)
				return err
			}
		}

		return nil

	case string(models.EventCreateDMSKey), string(models.EventUpdateDMSMetadataKey):
		var dms *models.DMS
		var err error

		isUpdateEvent := false
		var updatedDMS *models.UpdateModel[models.DMS]

		if event.Type() == string(models.EventCreateDMSKey) {
			dms, err = eventbus.GetEventBody[models.DMS](event)
			if err != nil {
				logDecodeError(event.ID(), event.Type(), "DMS", err)
				return nil
			}
		} else {
			updatedDMS, err = eventbus.GetEventBody[models.UpdateModel[models.DMS]](event)
			if err != nil {
				logDecodeError(event.ID(), event.Type(), "UpdateModel DMS", err)
				return nil
			}

			isUpdateEvent = true
			dms = &updatedDMS.Updated
		}

		var dmsAwsAutomationConfig models.IotAWSDMSMetadata
		hasKey, err := helpers.GetMetadataToStruct(dms.Metadata, models.AWSIoTMetadataKey(svc.ConnectorID), &dmsAwsAutomationConfig)
		if err != nil {
			err = fmt.Errorf("could not decode metadata with key %s: %s", models.CAMetadataMonitoringExpirationDeltasKey, err)
			logger.Error(err)
			return err
		}

		if !hasKey {
			logrus.Warnf("skipping event %s, DMS doesn't have %s key", event.Type(), models.AWSIoTMetadataKey(svc.ConnectorID))
			return nil
		}

		if dmsAwsAutomationConfig.RegistrationMode == models.JitpAWSIoTRegistrationMode {
			err = svc.RegisterUpdateJITPProvisioner(context.Background(), iot.RegisterUpdateJITPProvisionerInput{
				DMS:           dms,
				AwsJITPConfig: dmsAwsAutomationConfig,
			})
			if err != nil {
				err = fmt.Errorf("something went wrong while registering JITP template for DMS %s: %s", dms.ID, err)
				logger.Error(err)
				return err
			}
		}

		if isUpdateEvent {
			changedManagedCAs := !lms_slices.UnorderedEqualContent(updatedDMS.Previous.Settings.CADistributionSettings.ManagedCAs, updatedDMS.Updated.Settings.CADistributionSettings.ManagedCAs, func(e1, e2 string) bool { return e1 == e2 })
			if changedManagedCAs {
				_, err = svc.DeviceSDK.GetDeviceByDMS(services.GetDevicesByDMSInput{
					DMSID: dms.ID,
					ListInput: resources.ListInput[models.Device]{
						ExhaustiveRun: true,
						ApplyFunc: func(device models.Device) {
							err = svc.UpdateDeviceShadow(iot.UpdateDeviceShadowInput{
								DeviceID:               device.ID,
								RemediationActionsType: []models.RemediationActionType{models.RemediationActionUpdateTrustAnchorList},
								DMSIoTAutomationConfig: dmsAwsAutomationConfig,
							})
							if err != nil {
								logger.Errorf("something went wrong while updating %s Thing Shadow: %s", device.ID, err)
								return
							}
						},
					},
				})

				if err != nil {
					err = fmt.Errorf("something went wrong while getting devices By DMS %s: %s", dms.ID, err)
					logger.Error(err)
					return err
				}
			}
		}
		return nil

	case string(models.EventCreateCAKey), string(models.EventImportCAKey), string(models.EventUpdateCAMetadataKey):
		var ca *models.CACertificate
		var err error
		switch event.Type() {
		case string(models.EventUpdateCAMetadataKey):
			updatedCA, err := eventbus.GetEventBody[models.UpdateModel[models.CACertificate]](event)
			if err != nil {
				logDecodeError(event.ID(), event.Type(), "UpdateModel CACertificate", err)
				return nil
			}

			ca = &updatedCA.Updated
		default:
			ca, err = eventbus.GetEventBody[models.CACertificate](event)
			if err != nil {
				logDecodeError(event.ID(), event.Type(), "CACertificate", err)
				return nil
			}
		}

		var awsIoTCoreCACfg models.IoTAWSCAMetadata
		hasKey, err := helpers.GetMetadataToStruct(ca.Metadata, models.AWSIoTMetadataKey(svc.ConnectorID), &awsIoTCoreCACfg)
		if err != nil {
			err = fmt.Errorf("error while getting %s key: %s", models.AWSIoTMetadataKey(svc.ConnectorID), err)
			logger.Error(err)
			return err
		}

		if !hasKey {
			logrus.Warnf("skipping event %s, CA doesn't have %s key", event.Type(), models.AWSIoTMetadataKey(svc.ConnectorID))
			return nil
		}

		_, err = svc.RegisterCA(context.Background(), iot.RegisterCAInput{
			CACertificate:         *ca,
			RegisterConfiguration: awsIoTCoreCACfg,
		})
		if err != nil {
			err = fmt.Errorf("could not register CA %s - %s: %s", ca.ID, ca.Subject.CommonName, err)
			logger.Error(err)
			return err
		}

		return nil
	default:
		return nil
	}
}
