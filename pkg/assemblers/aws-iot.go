package assemblers

import (
	"context"
	"encoding/json"
	"fmt"
	"slices"
	"strings"

	"github.com/ThreeDotsLabs/watermill/message"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/sqs"
	"github.com/cloudevents/sdk-go/v2/event"
	"github.com/lamassuiot/lamassuiot/v2/pkg/config"
	"github.com/lamassuiot/lamassuiot/v2/pkg/helpers"
	lms_slices "github.com/lamassuiot/lamassuiot/v2/pkg/helpers/slices"
	"github.com/lamassuiot/lamassuiot/v2/pkg/messaging"
	"github.com/lamassuiot/lamassuiot/v2/pkg/models"
	"github.com/lamassuiot/lamassuiot/v2/pkg/resources"
	"github.com/lamassuiot/lamassuiot/v2/pkg/services"
	"github.com/lamassuiot/lamassuiot/v2/pkg/services/iot"
	"github.com/sirupsen/logrus"
	log "github.com/sirupsen/logrus"
)

func AssembleAWSIoTManagerService(conf config.IotAWS, caService services.CAService, dmsService services.DMSManagerService, deviceService services.DeviceManagerService) (*iot.AWSCloudConnectorService, error) {
	lSvc := helpers.ConfigureLogger(conf.Logs.Level, "Service")
	lMessaging := helpers.ConfigureLogger(conf.BaseConfig.EventBus.LogLevel, "Messaging")

	awsCfg, err := config.GetAwsSdkConfig(conf.AWSSDKConfig)
	if err != nil {
		return nil, fmt.Errorf("could not get aws config: %s", err)
	}

	awsConnectorSvc, err := iot.NewAWSCloudConnectorServiceService(iot.AWSCloudConnectorBuilder{
		Conf:        *awsCfg,
		Logger:      lSvc,
		ConnectorID: conf.ConnectorID,
		CaSDK:       caService,
		DmsSDK:      dmsService,
		DeviceSDK:   deviceService,
	})
	if err != nil {
		log.Fatal(err)
	}

	busName := strings.ReplaceAll(conf.ConnectorID, "aws.", "-")
	eventBus, err := messaging.NewMessagingEngine(lMessaging, conf.EventBus, fmt.Sprintf("aws-connector-%s", busName))
	if err != nil {
		return nil, fmt.Errorf("could not setup event bus: %s", err)
	}

	panicHandler := func(eventType string, msg *message.Message) {
		if err := recover(); err != nil {
			serializedMsg := "<message is nil>"
			if msg != nil && msg.Payload != nil {
				serializedMsg = string(msg.Payload)
			}
			lMessaging.Errorf("prevented panic while handling %s event. Faulty message: %s", eventType, serializedMsg)
		}
	}

	subscribeAndHandle := func(eventType string, messageHandler func(msg *message.Message)) error {
		subscriber, err := eventBus.Subscriber.Subscribe(context.Background(), eventType)
		if err != nil {
			return err
		}

		panicSafeMessageHandler := func(msg *message.Message) {
			defer panicHandler(eventType, msg)
			messageHandler(msg)
		}

		for {
			select {
			case message := <-subscriber:
				panicSafeMessageHandler(message)
				message.Ack()
			}
		}
	}

	lamassuEventHandler := func(msg *message.Message) {
		event, err := messaging.ParseCloudEvent(msg.Payload)
		if err != nil {
			lMessaging.Errorf("Something went wrong while processing cloud event: %s", err)
		}

		eventHandler(lMessaging, event, *awsConnectorSvc)
	}

	go subscribeAndHandle("#", lamassuEventHandler)

	go func() {
		lSvc.Infof("starting SQS thread")
		sqsQueueName := fmt.Sprintf("https://sqs.%s.amazonaws.com/%s/%s", awsConnectorSvc.Region, awsConnectorSvc.AccountID, "Lamassu-IoT-SYNC-EventBridgeOutput6A8BBEEC-LaYbNuW753SC")

		for {
			lSvc.Debugf("reading from queue %s", sqsQueueName)
			sqsOutput, err := awsConnectorSvc.SqsSDK.ReceiveMessage(context.Background(), &sqs.ReceiveMessageInput{
				QueueUrl:            aws.String(sqsQueueName),
				MaxNumberOfMessages: int32(10),
				WaitTimeSeconds:     int32(20),
			})

			if err != nil {
				lSvc.Errorf("could not receive SQS messages: %s", err)
				return
			}

			totalInBatch := len(sqsOutput.Messages)
			lSvc.Tracef("received sqs batch messages of size %d ", totalInBatch)
			for idx, sqsMessage := range sqsOutput.Messages {
				lSvc.Tracef("message [%d/%d]: %s", idx+1, totalInBatch, *sqsMessage.Body)
			}
		}
	}()

	return awsConnectorSvc, nil
}

func eventHandler(logger *logrus.Entry, cloudEvent *event.Event, awsConnectorSvc iot.AWSCloudConnectorService) {
	logDecodeError := func(eventID string, eventType string, modelObject string, err error) {
		logger.Errorf("could not decode event '%s' into model '%s' object. Skipping event with ID %s: %s", eventType, modelObject, eventID, err)
	}

	logger.Tracef("incoming cloud event: type=%s source=%s id=%s", cloudEvent.Type(), cloudEvent.Source(), cloudEvent.ID())
	if cloudEvent.Source() == models.AWSIoTSource(awsConnectorSvc.ConnectorID) {
		//this prevents processing events generated by this service, and as a consequence of Updating/Creating/Deleting on other Lamassu services,
		//otherwise, the would be a possible infinite loop
		logger.Tracef("dropping cloud event. event source indicates that was originated by this container/service: type=%s source=%s id=%s", cloudEvent.Type(), cloudEvent.Source(), cloudEvent.ID())
		return
	}

	switch cloudEvent.Type() {
	case string(models.EventBindDeviceIdentityKey):
		bindEvent, err := getEventBody[models.BindIdentityToDeviceOutput](cloudEvent)
		if err != nil {
			logDecodeError(cloudEvent.ID(), cloudEvent.Type(), "Certificate", err)
			return
		}

		dms := bindEvent.DMS

		var dmsAwsAutomationConfig models.IotAWSDMSMetadata
		hasKey, err := helpers.GetMetadataToStruct(dms.Metadata, models.AWSIoTMetadataKey(awsConnectorSvc.ConnectorID), &dmsAwsAutomationConfig)
		if err != nil {
			logger.Errorf("could not decode metadata with key %s: %s", models.CAMetadataMonitoringExpirationDeltasKey, err)
			return
		}

		if !hasKey {
			logrus.Warnf("skipping event %s, DMS doesn't have %s key", cloudEvent.Type(), models.AWSIoTMetadataKey(awsConnectorSvc.ConnectorID))
			return
		}

		if dmsAwsAutomationConfig.RegistrationMode == models.AutomaticAWSIoTRegistrationMode {
			thingID := bindEvent.Certificate.Subject.CommonName
			logrus.Infof("registering %s device", thingID)
			err = awsConnectorSvc.RegisterAndAttachThing(iot.RegisterAndAttachThingInput{
				DeviceID:               thingID,
				DMSIoTAutomationConfig: dmsAwsAutomationConfig,
				BindedIdentity:         *bindEvent,
			})
			if err != nil {
				logrus.Errorf("something went wrong while registering device %s: %s", thingID, err)
				return
			}
		}

	case string(models.EventUpdateDeviceMetadataKey):
		deviceUpdate, err := getEventBody[models.UpdateModel[models.Device]](cloudEvent)
		if err != nil {
			logDecodeError(cloudEvent.ID(), cloudEvent.Type(), "Device", err)
			return
		}

		device := deviceUpdate.Updated
		var deviceMetaAWS models.DeviceAWSMetadata
		hasKey, err := helpers.GetMetadataToStruct(device.Metadata, models.AWSIoTMetadataKey(awsConnectorSvc.ConnectorID), &deviceMetaAWS)
		if err != nil {
			logger.Errorf("could not decode metadata with key %s: %s", models.AWSIoTMetadataKey(awsConnectorSvc.ConnectorID), err)
			return
		}

		if !hasKey {
			logrus.Warnf("skipping event %s, Device doesn't have %s key", cloudEvent.Type(), models.AWSIoTMetadataKey(awsConnectorSvc.ConnectorID))
			return
		}

		dms, err := awsConnectorSvc.DmsSDK.GetDMSByID(context.Background(), services.GetDMSByIDInput{
			ID: device.DMSOwner,
		})
		if err != nil {
			logger.Errorf("could not get DMS %s: %s", device.DMSOwner, err)
			return
		}

		var dmsAWSConf models.IotAWSDMSMetadata
		hasKey, err = helpers.GetMetadataToStruct(dms.Metadata, models.AWSIoTMetadataKey(awsConnectorSvc.ConnectorID), &dmsAWSConf)
		if err != nil {
			logger.Errorf("could not decode metadata with key %s: %s", models.AWSIoTMetadataKey(awsConnectorSvc.ConnectorID), err)
			return
		}

		if !hasKey {
			logrus.Warnf("skipping event %s, DMS doesn't have %s key", cloudEvent.Type(), models.AWSIoTMetadataKey(awsConnectorSvc.ConnectorID))
			return
		}

		if len(deviceMetaAWS.Actions) > 0 {
			err = awsConnectorSvc.UpdateDeviceShadow(iot.UpdateDeviceShadowInput{
				DeviceID:               device.ID,
				RemediationActionsType: deviceMetaAWS.Actions,
				DMSIoTAutomationConfig: dmsAWSConf,
			})
			if err != nil {
				logger.Errorf("something went wrong while updating %s Thing Shadow: %s", device.ID, err)
				return
			}
		}

	case string(models.EventUpdateCertificateMetadataKey):
		certUpdate, err := getEventBody[models.UpdateModel[models.Certificate]](cloudEvent)
		if err != nil {
			logDecodeError(cloudEvent.ID(), cloudEvent.Type(), "Certificate", err)
			return
		}

		cert := certUpdate.Updated

		var certExpirationDeltas models.CAMetadataMonitoringExpirationDeltas
		hasKey, err := helpers.GetMetadataToStruct(cert.Metadata, models.CAMetadataMonitoringExpirationDeltasKey, &certExpirationDeltas)
		if err != nil {
			logger.Errorf("could not decode metadata with key %s: %s", models.CAMetadataMonitoringExpirationDeltasKey, err)
			return
		}

		if !hasKey {
			logrus.Warnf("skipping event %s, Certificate doesn't have %s key", cloudEvent.Type(), models.CAMetadataMonitoringExpirationDeltasKey)
			return
		}

		preventiveIdx := slices.IndexFunc(certExpirationDeltas, func(med models.MonitoringExpirationDelta) bool {
			if med.Name == "Preventive" {
				return true
			}
			return false
		})

		var attachedBy models.CAAttachedToDevice
		hasKey, err = helpers.GetMetadataToStruct(cert.Metadata, models.CAAttachedToDeviceKey, &attachedBy)
		if err != nil {
			logger.Errorf("could not decode metadata with key %s: %s", models.CAAttachedToDeviceKey, err)
			return
		}

		if !hasKey {
			logrus.Warnf("skipping event %s, Certificate doesn't have %s key", cloudEvent.Type(), models.CAAttachedToDeviceKey)
			return
		}

		dms, err := awsConnectorSvc.DmsSDK.GetDMSByID(context.Background(), services.GetDMSByIDInput{
			ID: attachedBy.AuthorizedBy.RAID,
		})
		if err != nil {
			logger.Errorf("could not get DMS %s: %s", attachedBy.AuthorizedBy.RAID, err)
			return
		}

		var dmsAWSConf models.IotAWSDMSMetadata
		hasKey, err = helpers.GetMetadataToStruct(dms.Metadata, models.AWSIoTMetadataKey(awsConnectorSvc.ConnectorID), &dmsAWSConf)
		if err != nil {
			logger.Errorf("could not decode metadata with key %s: %s", models.AWSIoTMetadataKey(awsConnectorSvc.ConnectorID), err)
			return
		}

		if !hasKey {
			logrus.Warnf("skipping event %s, DMS doesn't have %s key", cloudEvent.Type(), models.AWSIoTMetadataKey(awsConnectorSvc.ConnectorID))
			return
		}

		if preventiveIdx >= 0 && certExpirationDeltas[preventiveIdx].Triggered {
			err = awsConnectorSvc.UpdateDeviceShadow(iot.UpdateDeviceShadowInput{
				DeviceID:               cert.Subject.CommonName,
				RemediationActionsType: []models.RemediationActionType{models.RemediationActionUpdateCertificate},
				DMSIoTAutomationConfig: dmsAWSConf,
			})
			if err != nil {
				logger.Errorf("something went wrong while updating %s Thing Shadow: %s", attachedBy.DeviceID, err)
				return
			}
		}

	case string(models.EventCreateDMSKey), string(models.EventUpdateDMSMetadataKey):
		var dms *models.DMS
		var err error

		isUpdateEvent := false
		var updatedDMS *models.UpdateModel[models.DMS]

		if cloudEvent.Type() == string(models.EventCreateDMSKey) {
			dms, err = getEventBody[models.DMS](cloudEvent)
			if err != nil {
				logDecodeError(cloudEvent.ID(), cloudEvent.Type(), "DMS", err)
				return
			}
		} else {
			updatedDMS, err = getEventBody[models.UpdateModel[models.DMS]](cloudEvent)
			if err != nil {
				logDecodeError(cloudEvent.ID(), cloudEvent.Type(), "UpdateModel DMS", err)
				return
			}

			isUpdateEvent = true
			dms = &updatedDMS.Updated
		}

		var dmsAwsAutomationConfig models.IotAWSDMSMetadata
		hasKey, err := helpers.GetMetadataToStruct(dms.Metadata, models.AWSIoTMetadataKey(awsConnectorSvc.ConnectorID), &dmsAwsAutomationConfig)
		if err != nil {
			logger.Errorf("could not decode metadata with key %s: %s", models.CAMetadataMonitoringExpirationDeltasKey, err)
			return
		}

		if !hasKey {
			logrus.Warnf("skipping event %s, DMS doesn't have %s key", cloudEvent.Type(), models.AWSIoTMetadataKey(awsConnectorSvc.ConnectorID))
			return
		}

		if dmsAwsAutomationConfig.RegistrationMode == models.JitpAWSIoTRegistrationMode {
			err = awsConnectorSvc.RegisterUpdateJITPProvisioner(context.Background(), iot.RegisterUpdateJITPProvisionerInput{
				DMS:           dms,
				AwsJITPConfig: dmsAwsAutomationConfig,
			})
			if err != nil {
				logger.Errorf("something went wrong while registering JITP template for DMS %s: %s", dms.ID, err)
				return
			}
		}

		if isUpdateEvent {
			changedManagedCAs := !lms_slices.UnorderedEqualContent(updatedDMS.Previous.Settings.CADistributionSettings.ManagedCAs, updatedDMS.Updated.Settings.CADistributionSettings.ManagedCAs, func(e1, e2 string) bool { return e1 == e2 })
			if changedManagedCAs {
				awsConnectorSvc.DeviceSDK.GetDeviceByDMS(services.GetDevicesByDMSInput{
					DMSID: dms.ID,
					ListInput: resources.ListInput[models.Device]{
						ExhaustiveRun: true,
						ApplyFunc: func(device models.Device) {
							err = awsConnectorSvc.UpdateDeviceShadow(iot.UpdateDeviceShadowInput{
								DeviceID:               device.ID,
								RemediationActionsType: []models.RemediationActionType{models.RemediationActionUpdateTrustAnchorList},
								DMSIoTAutomationConfig: dmsAwsAutomationConfig,
							})
							if err != nil {
								logger.Errorf("something went wrong while updating %s Thing Shadow: %s", device.ID, err)
								return
							}
						},
					},
				})

			}
		}

	case string(models.EventCreateCAKey), string(models.EventImportCAKey), string(models.EventUpdateCAMetadataKey):
		var ca *models.CACertificate
		var err error
		switch cloudEvent.Type() {
		case string(models.EventUpdateCAMetadataKey):
			updatedCA, err := getEventBody[models.UpdateModel[models.CACertificate]](cloudEvent)
			if err != nil {
				logDecodeError(cloudEvent.ID(), cloudEvent.Type(), "UpdateModel CACertificate", err)
				return
			}

			ca = &updatedCA.Updated
		default:
			ca, err = getEventBody[models.CACertificate](cloudEvent)
			if err != nil {
				logDecodeError(cloudEvent.ID(), cloudEvent.Type(), "CACertificate", err)
				return
			}
		}

		var awsIoTCoreCACfg models.IoTAWSCAMetadata
		hasKey, err := helpers.GetMetadataToStruct(ca.Metadata, models.AWSIoTMetadataKey(awsConnectorSvc.ConnectorID), &awsIoTCoreCACfg)
		if err != nil {
			logrus.Errorf("error while getting %s key: %s", models.AWSIoTMetadataKey(awsConnectorSvc.ConnectorID), err)
			return
		}

		if !hasKey {
			logrus.Warnf("skipping event %s, CA doesn't have %s key", cloudEvent.Type(), models.AWSIoTMetadataKey(awsConnectorSvc.ConnectorID))
			return
		}

		awsConnectorSvc.RegisterCA(context.Background(), iot.RegisterCAInput{
			CACertificate:         *ca,
			RegisterConfiguration: awsIoTCoreCACfg,
		})
	}
}

func getEventBody[E any](cloudEvent *event.Event) (*E, error) {
	var elem *E
	if cloudEvent == nil {
		return nil, fmt.Errorf("cloud event is null")
	}

	if cloudEvent.Data() == nil {
		return nil, fmt.Errorf("cloud event data is null")
	}

	eventDataBytes := cloudEvent.Data()
	err := json.Unmarshal(eventDataBytes, &elem)
	return elem, err
}
